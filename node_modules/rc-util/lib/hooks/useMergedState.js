"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = useMergedState;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var React = _interopRequireWildcard(require("react"));

var _useEvent = _interopRequireDefault(require("./useEvent"));

var _useLayoutEffect = _interopRequireDefault(require("./useLayoutEffect"));

var _useState3 = _interopRequireDefault(require("./useState"));

/**
 * Similar to `useState` but will use props value if provided.
 * Note that internal use rc-util `useState` hook.
 */
function useMergedState(defaultStateValue, option) {
  var _ref = option || {},
      defaultValue = _ref.defaultValue,
      value = _ref.value,
      onChange = _ref.onChange,
      postState = _ref.postState;

  var _useState = (0, _useState3.default)(function () {
    if (value !== undefined) {
      return value;
    }

    if (defaultValue !== undefined) {
      return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
    }

    return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
  }),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      innerValue = _useState2[0],
      setInnerValue = _useState2[1];

  var mergedValue = value !== undefined ? value : innerValue;
  var postMergedValue = postState ? postState(mergedValue) : mergedValue; // setState

  var onChangeFn = (0, _useEvent.default)(onChange);

  var _React$useState = React.useState(),
      _React$useState2 = (0, _slicedToArray2.default)(_React$useState, 2),
      changePrevValue = _React$useState2[0],
      setChangePrevValue = _React$useState2[1];

  var triggerChange = (0, _useEvent.default)(function (updater) {
    setChangePrevValue(mergedValue);
    setInnerValue(function (prev) {
      var nextValue = typeof updater === 'function' ? updater(prev) : updater;
      return nextValue;
    });
  }); // Effect to trigger onChange

  (0, _useLayoutEffect.default)(function () {
    if (changePrevValue !== undefined && changePrevValue !== innerValue) {
      onChangeFn(innerValue, changePrevValue);
    }
  }, [changePrevValue, innerValue, onChangeFn]); // Effect of reset value to `undefined`

  var prevValueRef = React.useRef(value);
  React.useEffect(function () {
    if (value === undefined && value !== prevValueRef.current) {
      setInnerValue(value);
    }

    prevValueRef.current = value;
  }, [value]);
  return [postMergedValue, triggerChange];
}